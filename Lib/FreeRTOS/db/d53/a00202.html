<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lib::FreeRTOS: RTOS::StreamBuffer Class Reference</title>
<link rel="icon" href="../../Arch_FreeRTOS_64.png" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../Arch_FreeRTOS_64.png"/></td>
  <td id="projectalign">
   <div id="projectname">Lib::FreeRTOS<span id="projectnumber">&#160;ver: 6.01</span>
   </div>
   <div id="projectbrief">Free RTOS C++ Wrapper Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d53/a00202.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d8/d72/a00199.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">RTOS::StreamBuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A C++ wrapper for FreeRTOS Stream Buffer. </p>
<p>This class provides a RAII-style interface for managing FreeRTOS stream buffers. It ensures proper creation, usage, and deletion of stream buffers. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d1/dd4/a00267.html#_a0">StreamBuffer</a>.</dd>
</dl>
</div>
<p><code>#include &lt;StreamBuffer.hpp&gt;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Collaboration diagram for RTOS::StreamBuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="../../d3/db1/a00200.png" border="0" usemap="#a_r_t_o_s_1_1_stream_buffer_coll__map" alt="Collaboration graph"/></div>
<map name="a_r_t_o_s_1_1_stream_buffer_coll__map" id="a_r_t_o_s_1_1_stream_buffer_coll__map">
<area shape="rect" title="A C++ wrapper for FreeRTOS Stream Buffer." alt="" coords="5,5,152,288"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac43f2585fb807014368f17cd4dd8bc9e" id="r_ac43f2585fb807014368f17cd4dd8bc9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac43f2585fb807014368f17cd4dd8bc9e">Handle</a> = StreamBufferHandle_t</td></tr>
<tr class="memdesc:ac43f2585fb807014368f17cd4dd8bc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for StreamBufferHandle_t.  <br /></td></tr>
<tr class="separator:ac43f2585fb807014368f17cd4dd8bc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d894360f80c822b178de66210a2bc6a" id="r_a6d894360f80c822b178de66210a2bc6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d894360f80c822b178de66210a2bc6a">StreamBuffer</a> ()=default</td></tr>
<tr class="memdesc:a6d894360f80c822b178de66210a2bc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for the StreamBuffer class.  <br /></td></tr>
<tr class="separator:a6d894360f80c822b178de66210a2bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4279301601dc12497575fbe9b250f62a" id="r_a4279301601dc12497575fbe9b250f62a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4279301601dc12497575fbe9b250f62a">~StreamBuffer</a> ()</td></tr>
<tr class="memdesc:a4279301601dc12497575fbe9b250f62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the StreamBuffer class.  <br /></td></tr>
<tr class="separator:a4279301601dc12497575fbe9b250f62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c511443cf2207c917749583857480a" id="r_aa2c511443cf2207c917749583857480a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2c511443cf2207c917749583857480a">create</a> (size_t bufferSize, size_t triggerLevel)</td></tr>
<tr class="memdesc:aa2c511443cf2207c917749583857480a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new stream buffer using dynamically allocated memory.  <br /></td></tr>
<tr class="separator:aa2c511443cf2207c917749583857480a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e72fe0b7e6d6115d71d9d7e789cdb5" id="r_a61e72fe0b7e6d6115d71d9d7e789cdb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e72fe0b7e6d6115d71d9d7e789cdb5">destroy</a> ()</td></tr>
<tr class="memdesc:a61e72fe0b7e6d6115d71d9d7e789cdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the stream buffer.  <br /></td></tr>
<tr class="separator:a61e72fe0b7e6d6115d71d9d7e789cdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fda4beeb6f0e9c96c01940d07010c28" id="r_a5fda4beeb6f0e9c96c01940d07010c28"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fda4beeb6f0e9c96c01940d07010c28">send</a> (const void *src, size_t len, uint32_t ticksToWait)</td></tr>
<tr class="memdesc:a5fda4beeb6f0e9c96c01940d07010c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the stream buffer.  <br /></td></tr>
<tr class="separator:a5fda4beeb6f0e9c96c01940d07010c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d70196c59bd638cff19681e63084b" id="r_a955d70196c59bd638cff19681e63084b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a955d70196c59bd638cff19681e63084b">sendFromISR</a> (const void *src, size_t len)</td></tr>
<tr class="memdesc:a955d70196c59bd638cff19681e63084b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the stream buffer from an ISR.  <br /></td></tr>
<tr class="separator:a955d70196c59bd638cff19681e63084b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3a5525eb79326f77b9ca87d6cb1c9d" id="r_a3f3a5525eb79326f77b9ca87d6cb1c9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3a5525eb79326f77b9ca87d6cb1c9d">receive</a> (void *dst, size_t len, uint32_t ticksToWait)</td></tr>
<tr class="memdesc:a3f3a5525eb79326f77b9ca87d6cb1c9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from the stream buffer.  <br /></td></tr>
<tr class="separator:a3f3a5525eb79326f77b9ca87d6cb1c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e38b8314da1a881b4dd216e8768eca" id="r_a63e38b8314da1a881b4dd216e8768eca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e38b8314da1a881b4dd216e8768eca">receiveFromISR</a> (void *dst, size_t len)</td></tr>
<tr class="memdesc:a63e38b8314da1a881b4dd216e8768eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message from the stream buffer in an ISR context.  <br /></td></tr>
<tr class="separator:a63e38b8314da1a881b4dd216e8768eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106b6b1961b742c76bd83f3d032aad3a" id="r_a106b6b1961b742c76bd83f3d032aad3a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a106b6b1961b742c76bd83f3d032aad3a">getBytesAvailable</a> () const</td></tr>
<tr class="memdesc:a106b6b1961b742c76bd83f3d032aad3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes available in the stream buffer.  <br /></td></tr>
<tr class="separator:a106b6b1961b742c76bd83f3d032aad3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa51825dff8d1fb8914b5700becd22a" id="r_a9fa51825dff8d1fb8914b5700becd22a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa51825dff8d1fb8914b5700becd22a">getSpacesAvailable</a> () const</td></tr>
<tr class="memdesc:a9fa51825dff8d1fb8914b5700becd22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of spaces available in the stream buffer.  <br /></td></tr>
<tr class="separator:a9fa51825dff8d1fb8914b5700becd22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c2af499abb7cb673d5d4dba7ecb433" id="r_a37c2af499abb7cb673d5d4dba7ecb433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37c2af499abb7cb673d5d4dba7ecb433">setTriggerLevel</a> (size_t triger_level)</td></tr>
<tr class="memdesc:a37c2af499abb7cb673d5d4dba7ecb433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the trigger level for the stream buffer.  <br /></td></tr>
<tr class="separator:a37c2af499abb7cb673d5d4dba7ecb433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945ae0f4f0d0051decd64f9e208f59fc" id="r_a945ae0f4f0d0051decd64f9e208f59fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945ae0f4f0d0051decd64f9e208f59fc">reset</a> ()</td></tr>
<tr class="memdesc:a945ae0f4f0d0051decd64f9e208f59fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the stream buffer.  <br /></td></tr>
<tr class="separator:a945ae0f4f0d0051decd64f9e208f59fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63276981f0f2652f909f8caf99eded6" id="r_ac63276981f0f2652f909f8caf99eded6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac63276981f0f2652f909f8caf99eded6">isEmpty</a> () const</td></tr>
<tr class="memdesc:ac63276981f0f2652f909f8caf99eded6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer is empty.  <br /></td></tr>
<tr class="separator:ac63276981f0f2652f909f8caf99eded6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28a179ad13782df9ebce66f220d9084" id="r_ab28a179ad13782df9ebce66f220d9084"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28a179ad13782df9ebce66f220d9084">isFull</a> () const</td></tr>
<tr class="memdesc:ab28a179ad13782df9ebce66f220d9084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer is full.  <br /></td></tr>
<tr class="separator:ab28a179ad13782df9ebce66f220d9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f44e79071890fe52737b0a611f8204b" id="r_a8f44e79071890fe52737b0a611f8204b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f44e79071890fe52737b0a611f8204b">operator Handle &amp;</a> ()</td></tr>
<tr class="memdesc:a8f44e79071890fe52737b0a611f8204b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion operator to return a reference to the internal handle.  <br /></td></tr>
<tr class="separator:a8f44e79071890fe52737b0a611f8204b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a0f30afe68cccb4fbb7ba9d3fb3f24" id="r_a19a0f30afe68cccb4fbb7ba9d3fb3f24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19a0f30afe68cccb4fbb7ba9d3fb3f24">isCreated</a> () const</td></tr>
<tr class="memdesc:a19a0f30afe68cccb4fbb7ba9d3fb3f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the stream buffer has been successfully created.  <br /></td></tr>
<tr class="separator:a19a0f30afe68cccb4fbb7ba9d3fb3f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac43f2585fb807014368f17cd4dd8bc9e" name="ac43f2585fb807014368f17cd4dd8bc9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43f2585fb807014368f17cd4dd8bc9e">&#9670;&#160;</a></span>Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ac43f2585fb807014368f17cd4dd8bc9e">RTOS::StreamBuffer::Handle</a> = StreamBufferHandle_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for StreamBufferHandle_t. </p>
<p>This type alias is used to simplify the usage of StreamBufferHandle_t within the code. It represents a handle to a stream buffer in FreeRTOS. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d894360f80c822b178de66210a2bc6a" name="a6d894360f80c822b178de66210a2bc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d894360f80c822b178de66210a2bc6a">&#9670;&#160;</a></span>StreamBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTOS::StreamBuffer::StreamBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for the StreamBuffer class. </p>
<p>This constructor initializes the stream buffer handle to nullptr. </p>

</div>
</div>
<a id="a4279301601dc12497575fbe9b250f62a" name="a4279301601dc12497575fbe9b250f62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4279301601dc12497575fbe9b250f62a">&#9670;&#160;</a></span>~StreamBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTOS::StreamBuffer::~StreamBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for the StreamBuffer class. </p>
<p>This destructor ensures that the stream buffer is properly destroyed before the object is destroyed. It uses an assertion to check that the stream buffer is not created at the time of destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2c511443cf2207c917749583857480a" name="aa2c511443cf2207c917749583857480a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c511443cf2207c917749583857480a">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::create </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>triggerLevel</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new stream buffer using dynamically allocated memory. </p>
<p>This function creates a new stream buffer using dynamically allocated memory. The stream buffer will be able to hold messages of the specified size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferSize</td><td>The size of the stream buffer in bytes. </td></tr>
    <tr><td class="paramname">triggerLevel</td><td>The trigger level for the stream buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer was created successfully, false otherwise. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d1/dd4/a00267.html#a1">StreamBuffer</a>.</dd>
</dl>

</div>
</div>
<a id="a61e72fe0b7e6d6115d71d9d7e789cdb5" name="a61e72fe0b7e6d6115d71d9d7e789cdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e72fe0b7e6d6115d71d9d7e789cdb5">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RTOS::StreamBuffer::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the stream buffer. </p>
<p>This function deletes the stream buffer if it has been created and sets the handle to nullptr. It ensures that the resources associated with the stream buffer are properly released. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d1/dd4/a00267.html#a4">StreamBuffer</a>.</dd>
</dl>

</div>
</div>
<a id="a106b6b1961b742c76bd83f3d032aad3a" name="a106b6b1961b742c76bd83f3d032aad3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106b6b1961b742c76bd83f3d032aad3a">&#9670;&#160;</a></span>getBytesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::getBytesAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of bytes available in the stream buffer. </p>
<p>This function returns the number of bytes available in the stream buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes available in the stream buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null. </dd></dl>

</div>
</div>
<a id="a9fa51825dff8d1fb8914b5700becd22a" name="a9fa51825dff8d1fb8914b5700becd22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa51825dff8d1fb8914b5700becd22a">&#9670;&#160;</a></span>getSpacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::getSpacesAvailable </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of spaces available in the stream buffer. </p>
<p>This function returns the number of spaces available in the stream buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of spaces available in the stream buffer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null. </dd></dl>

</div>
</div>
<a id="a19a0f30afe68cccb4fbb7ba9d3fb3f24" name="a19a0f30afe68cccb4fbb7ba9d3fb3f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a0f30afe68cccb4fbb7ba9d3fb3f24">&#9670;&#160;</a></span>isCreated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::isCreated </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream buffer has been successfully created. </p>
<p>This function returns a boolean value indicating whether the stream buffer has been created. It checks if the internal handle is not a null pointer.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer is created, false otherwise. </dd></dl>

</div>
</div>
<a id="ac63276981f0f2652f909f8caf99eded6" name="ac63276981f0f2652f909f8caf99eded6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63276981f0f2652f909f8caf99eded6">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream buffer is empty. </p>
<p>This function checks if the stream buffer is empty.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer is empty, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null. </dd></dl>

</div>
</div>
<a id="ab28a179ad13782df9ebce66f220d9084" name="ab28a179ad13782df9ebce66f220d9084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28a179ad13782df9ebce66f220d9084">&#9670;&#160;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::isFull </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the stream buffer is full. </p>
<p>This function checks if the stream buffer is full.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer is full, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null. </dd></dl>

</div>
</div>
<a id="a8f44e79071890fe52737b0a611f8204b" name="a8f44e79071890fe52737b0a611f8204b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f44e79071890fe52737b0a611f8204b">&#9670;&#160;</a></span>operator Handle &amp;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RTOS::StreamBuffer::operator <a class="el" href="#ac43f2585fb807014368f17cd4dd8bc9e">Handle</a> &amp; </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conversion operator to return a reference to the internal handle. </p>
<p>This operator allows the StreamBuffer object to be implicitly converted to a reference to its internal Handle object. This can be useful when you need to pass the handle to functions that require a Handle reference.</p>
<dl class="section return"><dt>Returns</dt><dd>Handle&amp; Reference to the internal handle. </dd></dl>

</div>
</div>
<a id="a3f3a5525eb79326f77b9ca87d6cb1c9d" name="a3f3a5525eb79326f77b9ca87d6cb1c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3a5525eb79326f77b9ca87d6cb1c9d">&#9670;&#160;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::receive </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ticksToWait</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message from the stream buffer. </p>
<p>This function attempts to receive a message from the stream buffer. It will block for the specified number of ticks if no message is immediately available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Pointer to the buffer where the received message will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer pointed to by dst. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time (in ticks) to wait for a message to become available.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received, or 0 if no message was received within the specified time.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null, the destination buffer is not null, and the length is non-zero. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d1/dd4/a00267.html#a3">StreamBuffer</a>.</dd>
</dl>

</div>
</div>
<a id="a63e38b8314da1a881b4dd216e8768eca" name="a63e38b8314da1a881b4dd216e8768eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e38b8314da1a881b4dd216e8768eca">&#9670;&#160;</a></span>receiveFromISR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives a message from the stream buffer in an ISR context. </p>
<p>This function attempts to receive a message from the stream buffer in an interrupt service routine (ISR) context. It will not block and will return immediately if no message is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Pointer to the buffer where the received message will be stored. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the buffer pointed to by dst.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes received, or 0 if no message was received.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null, the destination buffer is not null, and the length is non-zero. </dd></dl>

</div>
</div>
<a id="a945ae0f4f0d0051decd64f9e208f59fc" name="a945ae0f4f0d0051decd64f9e208f59fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945ae0f4f0d0051decd64f9e208f59fc">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::reset </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the stream buffer. </p>
<p>This function resets the stream buffer to its initial empty state. It asserts that the stream buffer handle is not null before attempting to reset the buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the stream buffer was successfully reset, false otherwise. </dd></dl>

</div>
</div>
<a id="a5fda4beeb6f0e9c96c01940d07010c28" name="a5fda4beeb6f0e9c96c01940d07010c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fda4beeb6f0e9c96c01940d07010c28">&#9670;&#160;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::send </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>ticksToWait</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message to the stream buffer. </p>
<p>This function sends a message to the stream buffer. The message is copied from the memory pointed to by <code>src</code> and has a length of <code>len</code> bytes. The function will block for up to <code>ticksToWait</code> ticks if there is not enough space in the buffer to hold the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the message to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the message in bytes. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>Maximum number of ticks to wait for space to become available in the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent to the buffer, which will be equal to <code>len</code> if the message was sent successfully, or 0 if the message could not be sent within the specified wait time.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null, that the source pointer is valid, and that the message length is greater than 0. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d1/dd4/a00267.html#a2">StreamBuffer</a>.</dd>
</dl>

</div>
</div>
<a id="a955d70196c59bd638cff19681e63084b" name="a955d70196c59bd638cff19681e63084b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955d70196c59bd638cff19681e63084b">&#9670;&#160;</a></span>sendFromISR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t RTOS::StreamBuffer::sendFromISR </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a message to the stream buffer from an ISR. </p>
<p>This function sends a message to the stream buffer from an interrupt service routine (ISR). The message is copied from the memory pointed to by <code>src</code> and has a length of <code>len</code> bytes. The function will not block and will return immediately if there is not enough space in the buffer to hold the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to the message to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Length of the message in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes actually sent to the buffer, which will be equal to <code>len</code> if the message was sent successfully, or 0 if the message could not be sent.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null, that the source pointer is valid, and that the message length is greater than 0. </dd></dl>

</div>
</div>
<a id="a37c2af499abb7cb673d5d4dba7ecb433" name="a37c2af499abb7cb673d5d4dba7ecb433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c2af499abb7cb673d5d4dba7ecb433">&#9670;&#160;</a></span>setTriggerLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool RTOS::StreamBuffer::setTriggerLevel </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>triger_level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the trigger level for the stream buffer. </p>
<p>This function sets the trigger level for the stream buffer. The trigger level is the number of bytes that must be available in the buffer before a task that is blocked on the buffer is unblocked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">triger_level</td><td>The trigger level for the stream buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the trigger level was successfully set, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function asserts that the stream buffer handle is not null. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="../../df/d98/a00107.html">StreamBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>RTOS</b></li><li class="navelem"><a class="el" href="../../db/d53/a00202.html">StreamBuffer</a></li>
    <li class="footer">Generated on Wed Feb 19 2025 for Lib::FreeRTOS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
