<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Tips and Tricks: Chain of Responsibility Design Pattern</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">var page_layout=1;</script>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(function() { init_search(); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="side-nav" class="ui-resizable side-nav-resizable"><!-- do not remove this div, it is closed by doxygen! -->
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">C++ Tips and Tricks<span id="projectnumber">&#160;2.00</span>
   </div>
   <div id="projectbrief">C++</div>
  </td>
 </tr>
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect" class="search-icon" onmouseover="return searchBox.OnSearchSelectShow()" onmouseout="return searchBox.OnSearchSelectHide()"><span class="search-icon-dropdown"></span></span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><div id="MSearchCloseImg" class="close-icon"></div></a>
          </span>
        </div>
</td></tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
</div><!-- top -->
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d9/d4b/a00117.html','../../',''); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
<div id="container"><div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Chain of Responsibility Design Pattern </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>В тази страница ще разгледаме Chain of Responsibility дизайн патърна в C++.</p>
<h3 class="doxsection"><a class="anchor" id="въведение-1"></a>
Въведение</h3>
<p>Chain of Responsibility е поведенчески дизайн патърн, който позволява на обектите да предават заявки по верига от обработващи обекти. Всеки обект във веригата решава дали да обработи заявката или да я предаде на следващия обект във веригата. Този подход премахва директната зависимост между подателя и получателя на заявката, като предоставя възможност за динамично определяне на обработващия обект по време на изпълнение. Това улеснява разширяемостта на системата, позволява добавяне на нови обработващи обекти без промяна на съществуващия код и подобрява гъвкавостта при обработка на различни типове заявки. Chain of Responsibility е особено полезен, когато е необходимо да се избегне твърдо кодиране на логиката за обработка на заявки и когато множество обекти могат да обработят една и съща заявка по различен начин.</p>
<h3 class="doxsection"><a class="anchor" id="пример-за-chain-of-responsibility"></a>
Пример за Chain of Responsibility:</h3>
<div class="fragment"><div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * @file ChainOfResponsibility.hpp</span></div>
<div class="line"><span class="comment"> * Demonstrates the Chain of Responsibility design pattern in C++ for handling requests by passing them along a chain.</span></div>
<div class="line"><span class="comment"> * This file defines an abstract handler interface and concrete handler classes (MonkeyHandler, SquirrelHandler,</span></div>
<div class="line"><span class="comment"> * DogHandler) that process specific requests or delegate them to the next handler in the chain. Includes a client code</span></div>
<div class="line"><span class="comment"> * example.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Handler interface for processing requests or delegating to the next handler in the chain.</span></div>
<div class="line"><span class="comment"> * Defines the contract for setting the next handler and handling requests, enabling flexible</span></div>
<div class="line"><span class="comment"> * composition of handler chains for request processing in embedded or UI applications.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>Handler {</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Sets the next handler in the chain and returns the handler for chaining.</span></div>
<div class="line"><span class="comment">     * @param handler Pointer to the next handler in the chain.</span></div>
<div class="line"><span class="comment">     * @return Pointer to the handler passed as parameter for chaining.</span></div>
<div class="line"><span class="comment">     * @pre handler must be a valid pointer or nullptr.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">virtual</span> Handler * setNext(Handler * handler) = 0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Handles the request or delegates it to the next handler in the chain.</span></div>
<div class="line"><span class="comment">     * @param request The request string to be processed.</span></div>
<div class="line"><span class="comment">     * @return Response string if handled, or empty string if not handled.</span></div>
<div class="line"><span class="comment">     * @pre None.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string handle(std::string request) = 0;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Virtual destructor for safe polymorphic destruction.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    <span class="keyword">virtual</span> ~Handler() = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Abstract base handler that implements chaining logic for request delegation.</span></div>
<div class="line"><span class="comment"> * Stores a pointer to the next handler and delegates requests if not handled by derived classes,</span></div>
<div class="line"><span class="comment"> * enabling flexible composition of handler chains for request processing.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>AbstractHandler : <span class="keyword">public</span> Handler {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Handler * nextHandler; <span class="comment">///&lt; Pointer to the next handler in the chain.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Constructs an AbstractHandler with no next handler.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    AbstractHandler() : nextHandler(nullptr) {}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Sets the next handler in the chain and returns the handler for chaining.</span></div>
<div class="line"><span class="comment">     * @param handler Pointer to the next handler in the chain.</span></div>
<div class="line"><span class="comment">     * @return Pointer to the handler passed as parameter for chaining.</span></div>
<div class="line"><span class="comment">     * @pre handler must be a valid pointer or nullptr.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    Handler * setNext(Handler * handler)<span class="keyword"> override </span>{</div>
<div class="line">        this-&gt;nextHandler = handler;</div>
<div class="line">        <span class="keywordflow">return</span> handler;</div>
<div class="line">    }</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Handles the request or delegates it to the next handler in the chain.</span></div>
<div class="line"><span class="comment">     * @param request The request string to be processed.</span></div>
<div class="line"><span class="comment">     * @return Response string if handled, or empty string if not handled.</span></div>
<div class="line"><span class="comment">     * @pre None.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    std::string handle(std::string request)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (this-&gt;nextHandler) { <span class="keywordflow">return</span> this-&gt;nextHandler-&gt;handle(request); }</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Handler for processing &quot;Banana&quot; requests.</span></div>
<div class="line"><span class="comment"> * Handles requests for &quot;Banana&quot; and delegates all other requests to the next handler in the chain.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>MonkeyHandler : <span class="keyword">public</span> AbstractHandler {</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Handles the request if it is &quot;Banana&quot;, otherwise delegates to the next handler.</span></div>
<div class="line"><span class="comment">     * @param request The request string to be processed.</span></div>
<div class="line"><span class="comment">     * @return Response string if handled, or result from next handler if not handled.</span></div>
<div class="line"><span class="comment">     * @pre None.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    std::string handle(std::string request)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;Banana&quot;</span>) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Monkey: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>; }</div>
<div class="line">        <span class="keywordflow">return</span> AbstractHandler::handle(request);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Handler for processing &quot;Nut&quot; requests.</span></div>
<div class="line"><span class="comment"> * Handles requests for &quot;Nut&quot; and delegates all other requests to the next handler in the chain.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>SquirrelHandler : <span class="keyword">public</span> AbstractHandler {</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Handles the request if it is &quot;Nut&quot;, otherwise delegates to the next handler.</span></div>
<div class="line"><span class="comment">     * @param request The request string to be processed.</span></div>
<div class="line"><span class="comment">     * @return Response string if handled, or result from next handler if not handled.</span></div>
<div class="line"><span class="comment">     * @pre None.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    std::string handle(std::string request)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;Nut&quot;</span>) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Squirrel: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>; }</div>
<div class="line">        <span class="keywordflow">return</span> AbstractHandler::handle(request);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Handler for processing &quot;MeatBall&quot; requests.</span></div>
<div class="line"><span class="comment"> * Handles requests for &quot;MeatBall&quot; and delegates all other requests to the next handler in the chain.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>DogHandler : <span class="keyword">public</span> AbstractHandler {</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">    /**</span></div>
<div class="line"><span class="comment">     * Handles the request if it is &quot;MeatBall&quot;, otherwise delegates to the next handler.</span></div>
<div class="line"><span class="comment">     * @param request The request string to be processed.</span></div>
<div class="line"><span class="comment">     * @return Response string if handled, or result from next handler if not handled.</span></div>
<div class="line"><span class="comment">     * @pre None.</span></div>
<div class="line"><span class="comment">     */</span></div>
<div class="line">    std::string handle(std::string request)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (request == <span class="stringliteral">&quot;MeatBall&quot;</span>) { <span class="keywordflow">return</span> <span class="stringliteral">&quot;Dog: I&#39;ll eat the &quot;</span> + request + <span class="stringliteral">&quot;.\n&quot;</span>; }</div>
<div class="line">        <span class="keywordflow">return</span> AbstractHandler::handle(request);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Demonstrates the chain of responsibility by passing requests through the handler chain.</span></div>
<div class="line"><span class="comment"> * @param handler Reference to the first handler in the chain.</span></div>
<div class="line"><span class="comment"> * @pre handler must be a valid Handler reference.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">void</span> clientCode(Handler &amp; handler) {</div>
<div class="line">    std::string food[] = {<span class="stringliteral">&quot;Nut&quot;</span>, <span class="stringliteral">&quot;Banana&quot;</span>, <span class="stringliteral">&quot;Cup of coffee&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string &amp; f : food) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Who wants a &quot;</span> &lt;&lt; f &lt;&lt; <span class="stringliteral">&quot;?\n&quot;</span>;</div>
<div class="line">        <span class="keyword">const</span> std::string result = handler.handle(f);</div>
<div class="line">        <span class="keywordflow">if</span> (!result.empty()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; result;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; f &lt;&lt; <span class="stringliteral">&quot; was left untouched.\n&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Entry point for demonstrating the Chain of Responsibility pattern.</span></div>
<div class="line"><span class="comment"> * @return Exit code for the application.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    MonkeyHandler * monkey = <span class="keyword">new</span> MonkeyHandler;</div>
<div class="line">    SquirrelHandler * squirrel = <span class="keyword">new</span> SquirrelHandler;</div>
<div class="line">    DogHandler * dog = <span class="keyword">new</span> DogHandler;</div>
<div class="line"> </div>
<div class="line">    monkey-&gt;setNext(squirrel)-&gt;setNext(dog);</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Chain: Monkey &gt; Squirrel &gt; Dog\n\n&quot;</span>;</div>
<div class="line">    clientCode(*monkey);</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nSubchain: Squirrel &gt; Dog\n\n&quot;</span>;</div>
<div class="line">    clientCode(*squirrel);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">delete</span> monkey;</div>
<div class="line">    <span class="keyword">delete</span> squirrel;</div>
<div class="line">    <span class="keyword">delete</span> dog;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h3 class="doxsection"><a class="anchor" id="подробно-описание-на-примера-1"></a>
Подробно описание на примера</h3>
<p>В този пример е реализирана верига от обработващи обекти, всеки от които наследява абстрактния клас <span class="tt">Handler</span>. Всеки обработващ обект (например <span class="tt">MonkeyHandler</span>, <span class="tt">SquirrelHandler</span>, <span class="tt">DogHandler</span>) проверява дали може да обработи дадена заявка (например "Nut", "Banana", "MeatBall"). Ако обработващият обект не може да обработи заявката, той я предава на следващия обект във веригата, ако такъв съществува. Това позволява динамично определяне на обработващия обект по време на изпълнение, без да се налага промяна на клиентския код. Клиентът създава верига от обработващи обекти и изпраща заявки към първия обект във веригата. Всеки обработващ обект решава дали да обработи заявката или да я предаде нататък. Така се постига гъвкавост и разширяемост при обработката на различни типове заявки, без да се нарушава принципът за отвореност/затвореност на системата.  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../index.html">DESIGN_PATTERNS Design Patterns in C++</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for C++ Tips and Tricks by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
