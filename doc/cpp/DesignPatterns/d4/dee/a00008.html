<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Design Patterns: Abstract Factory</title>
<link rel="icon" href="../../logo-new-winter.png" type="image/x-icon" />
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo-new-winter.png"/></td>
  <td id="projectalign">
   <div id="projectname">C++ Design Patterns<span id="projectnumber">&#160;1.00</span>
   </div>
   <div id="projectbrief">C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/dee/a00008.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Abstract Factory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Abstract Factory е модел за създаване на дизайн, който решава проблема със създаването на цели фамилии продукти, без да се уточняват техните конкретни класове.</p>
<p>Abstract Factory дефинира интерфейс за създаване на всички отделни продукти, но оставя действителното създаване на продукта на конкретни фабрични класове. Всеки тип фабрика отговаря на определена продуктова разновидност. Клиентският код извиква методите за създаване на фабричен обект, вместо да създава продукти директно с извикване на конструктор ( <code>new</code>оператор). Тъй като дадена фабрика съответства на един вариант на продукта, всички нейни продукти ще бъдат съвместими. Клиентският код работи с фабрики и продукти само чрез техните абстрактни интерфейси. Това позволява на клиентския код да работи с всякакви варианти на продукта, създадени от фабричния обект. Просто създавате нов бетонен фабричен клас и го предавате на клиентския код.</p>
<div class="fragment"><div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Each distinct product of a product family should have a base interface. All</span></div>
<div class="line"><span class="comment"> * variants of the product must implement this interface.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>AbstractProductA {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~AbstractProductA(){};</div>
<div class="line">  <span class="keyword">virtual</span> std::string UsefulFunctionA() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Concrete Products are created by corresponding Concrete Factories.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>ConcreteProductA1 : <span class="keyword">public</span> AbstractProductA {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  std::string UsefulFunctionA()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A1.&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ConcreteProductA2 : <span class="keyword">public</span> AbstractProductA {</div>
<div class="line">  std::string UsefulFunctionA()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product A2.&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Here&#39;s the the base interface of another product. All products can interact</span></div>
<div class="line"><span class="comment"> * with each other, but proper interaction is possible only between products of</span></div>
<div class="line"><span class="comment"> * the same concrete variant.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>AbstractProductB {<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * Product B is able to do its own thing...</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~AbstractProductB(){};</div>
<div class="line">  <span class="keyword">virtual</span> std::string UsefulFunctionB() <span class="keyword">const</span> = 0;<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * ...but it also can collaborate with the ProductA.</span></div>
<div class="line"><span class="comment">   *</span></div>
<div class="line"><span class="comment">   * The Abstract Factory makes sure that all products it creates are of the</span></div>
<div class="line"><span class="comment">   * same variant and thus, compatible.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  <span class="keyword">virtual</span> std::string AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator) <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Concrete Products are created by corresponding Concrete Factories.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>ConcreteProductB1 : <span class="keyword">public</span> AbstractProductB {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  std::string UsefulFunctionB()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B1.&quot;</span>;</div>
<div class="line">  }<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * The variant, Product B1, is only able to work correctly with the variant,</span></div>
<div class="line"><span class="comment">   * Product A1. Nevertheless, it accepts any instance of AbstractProductA as an</span></div>
<div class="line"><span class="comment">   * argument.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  std::string AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keyword">const</span> std::string result = collaborator.UsefulFunctionA();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ConcreteProductB2 : <span class="keyword">public</span> AbstractProductB {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  std::string UsefulFunctionB()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the product B2.&quot;</span>;</div>
<div class="line">  }<span class="comment"></span></div>
<div class="line"><span class="comment">  /**</span></div>
<div class="line"><span class="comment">   * The variant, Product B2, is only able to work correctly with the variant,</span></div>
<div class="line"><span class="comment">   * Product A2. Nevertheless, it accepts any instance of AbstractProductA as an</span></div>
<div class="line"><span class="comment">   * argument.</span></div>
<div class="line"><span class="comment">   */</span></div>
<div class="line">  std::string AnotherUsefulFunctionB(<span class="keyword">const</span> AbstractProductA &amp;collaborator)<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keyword">const</span> std::string result = collaborator.UsefulFunctionA();</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="stringliteral">&quot; )&quot;</span>;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * The Abstract Factory interface declares a set of methods that return</span></div>
<div class="line"><span class="comment"> * different abstract products. These products are called a family and are</span></div>
<div class="line"><span class="comment"> * related by a high-level theme or concept. Products of one family are usually</span></div>
<div class="line"><span class="comment"> * able to collaborate among themselves. A family of products may have several</span></div>
<div class="line"><span class="comment"> * variants, but the products of one variant are incompatible with products of</span></div>
<div class="line"><span class="comment"> * another.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>AbstractFactory {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> AbstractProductA *CreateProductA() <span class="keyword">const</span> = 0;</div>
<div class="line">  <span class="keyword">virtual</span> AbstractProductB *CreateProductB() <span class="keyword">const</span> = 0;</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Concrete Factories produce a family of products that belong to a single</span></div>
<div class="line"><span class="comment"> * variant. The factory guarantees that resulting products are compatible. Note</span></div>
<div class="line"><span class="comment"> * that signatures of the Concrete Factory&#39;s methods return an abstract product,</span></div>
<div class="line"><span class="comment"> * while inside the method a concrete product is instantiated.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>ConcreteFactory1 : <span class="keyword">public</span> AbstractFactory {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA1();</div>
<div class="line">  }</div>
<div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB1();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * Each Concrete Factory has a corresponding product variant.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"><span class="keyword">class </span>ConcreteFactory2 : <span class="keyword">public</span> AbstractFactory {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  AbstractProductA *CreateProductA()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductA2();</div>
<div class="line">  }</div>
<div class="line">  AbstractProductB *CreateProductB()<span class="keyword"> const override </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ConcreteProductB2();</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">/**</span></div>
<div class="line"><span class="comment"> * The client code works with factories and products only through abstract</span></div>
<div class="line"><span class="comment"> * types: AbstractFactory and AbstractProduct. This lets you pass any factory or</span></div>
<div class="line"><span class="comment"> * product subclass to the client code without breaking it.</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ClientCode(<span class="keyword">const</span> AbstractFactory &amp;factory) {</div>
<div class="line">  <span class="keyword">const</span> AbstractProductA *product_a = factory.CreateProductA();</div>
<div class="line">  <span class="keyword">const</span> AbstractProductB *product_b = factory.CreateProductB();</div>
<div class="line">  std::cout &lt;&lt; product_b-&gt;UsefulFunctionB() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  std::cout &lt;&lt; product_b-&gt;AnotherUsefulFunctionB(*product_a) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">  <span class="keyword">delete</span> product_a;</div>
<div class="line">  <span class="keyword">delete</span> product_b;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;</div>
<div class="line">  ConcreteFactory1 *f1 = <span class="keyword">new</span> ConcreteFactory1();</div>
<div class="line">  ClientCode(*f1);</div>
<div class="line">  <span class="keyword">delete</span> f1;</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;</div>
<div class="line">  ConcreteFactory2 *f2 = <span class="keyword">new</span> ConcreteFactory2();</div>
<div class="line">  ClientCode(*f2);</div>
<div class="line">  <span class="keyword">delete</span> f2;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a href="https://refactoring.guru/design-patterns/abstract-factory/cpp/example#lang-features">Abstract Factory</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../index.html">DESIGN_PATTERN DESIGN PATTERNS in C++</a></li><li class="navelem"><a class="el" href="../../dd/dad/a00005.html">Creational Patterns</a></li>
    <li class="footer">Generated on Tue Jan 7 2025 11:04:09 for C++ Design Patterns by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.1 </li>
  </ul>
</div>
</body>
</html>
